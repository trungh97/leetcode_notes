# LeetCode Problem Note

## 1. LeetCode Information

- **Title:** [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst)
- **Difficulty:**
  - [ ] ðŸŸ¢ Easy
  - [x] ðŸŸ¡ Medium
  - [ ] ðŸ”´ Hard
- **Tags:** #binarysearchtree #dfs

## 2. Code Idea

- Using DFS recursion/stack.
- Traverse inorder (Left-Node-Right), use an additional array to store the node value
- At this time, all the elements in the array should be a non-descending array.

## 3. Key Steps (Pseudo Code at High Level)

- Step 1:
  ```js
  const array = [];
  const stack = [];
  ```
- Step 2:

  ```js
  let curr = root;

  while (curr !== null || stack.length > 0) {
    // Put all of the left nodes to the stack first
    while (curr !== null) {
      stack.push(curr);
      curr = curr.left;
    }

    curr = stack.pop();

    // push the left node, then
    array.push(curr.val);
    curr = curr.right;
  }
  ```

- Step 3:

  ```js
  return array[k - 1]; // Because the tree index is 1-indexed
  ```

## 4. Related Patterns/Algorithms (Check all that apply)

- [ ] Array
- [ ] String
- [ ] Hash Table / Map
- [x] Stack
- [ ] Queue
- [ ] Linked List
- [x] Tree / Binary Tree
- [x] Binary Search Tree
- [ ] Heap / Priority Queue
- [x] Graph / BFS / DFS
- [ ] Sliding Window
- [ ] Two Pointers
- [ ] Divide and Conquer
- [ ] Dynamic Programming
- [ ] Greedy
- [ ] Backtracking
- [ ] Bit Manipulation
- [ ] Trie
- [ ] Union Find / Disjoint Set
- [ ] Topological Sort
- [ ] Math
- [ ] Recursion
- [ ] Other:

## 5. Time & Space Complexity

- **Time Complexity:** `O(n)`
  - `n` the total nodes of the tree
- **Space Complexity:** `O(h)`
  - `h` the height of the tree

## 6. Related Problems
