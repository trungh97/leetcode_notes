# LeetCode Problem Note

## 1. LeetCode Information

- **Title:** [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree)
- **Difficulty:**
  - [ ] ðŸŸ¢ Easy
  - [x] ðŸŸ¡ Medium
  - [ ] ðŸ”´ Hard
- **Tags:** #binarysearchtree #bfs #dfs

## 2. Code Idea

- Using DFS recursion/stack.
- The main idea is to memorize the range `(min, max)` value each time we visit a node:
  - `left`: `(min, node.val)`
  - `right`: `(node.val, max)`
- The node value should be in that range, unless return `false` immediately.

## 3. Key Steps (Pseudo Code at High Level)

- Step 1:
  ```js
  let count = 0;
  ```
- Step 2:

  ```js
  // `min` and `max` store the range value
  function traverse(node, min, max) {
    if (!node) return true;

    // if the node value is out of that range, return false
    if (node.val <= min || node.val >= max) return false;

    // else continue to traverse deeper
    return (
      traverse(node.left, min, node.val) && traverse(node.right, node.val, max)
    );
  }
  ```

- Step 3:

  ```js
  // Apply the dfs function to the root.
  return traverse(root, -Infinity, Infinity);
  ```

## 4. Related Patterns/Algorithms (Check all that apply)

- [ ] Array
- [ ] String
- [ ] Hash Table / Map
- [x] Stack
- [x] Queue
- [ ] Linked List
- [x] Tree / Binary Tree
- [ ] Binary Search Tree
- [ ] Heap / Priority Queue
- [x] Graph / BFS / DFS
- [ ] Sliding Window
- [ ] Two Pointers
- [ ] Divide and Conquer
- [ ] Dynamic Programming
- [ ] Greedy
- [ ] Backtracking
- [ ] Bit Manipulation
- [ ] Trie
- [ ] Union Find / Disjoint Set
- [ ] Topological Sort
- [ ] Math
- [ ] Recursion
- [ ] Other:

## 5. Time & Space Complexity

- **Time Complexity:** `O(n)`
  - `n` the total nodes of the tree
- **Space Complexity:** `O(h)`
  - `h` the height of the tree

## 6. Related Problems
