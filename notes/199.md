# LeetCode Problem Note

## 1. LeetCode Information

- **Title:** [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view)
- **Difficulty:**
  - [ ] ðŸŸ¢ Easy
  - [x] ðŸŸ¡ Medium
  - [ ] ðŸ”´ Hard
- **Tags:** #btree #bfs

## 2. Code Idea

- Using queue to perform Breadth-First Search.
- Each time we add nodes to queue, we iterate over the queue.
- Add the `right` node first, if the `right` node does not exist, add the `left` node to the queue, the `row` should receive only the first node value in each iteration.

## 3. Key Steps (Pseudo Code at High Level)

- Step 1:
  ```js
  let queue = [root];
  let res = [];
  ```
- Step 2:

  ```js
  while (queue.length > 0) {
    let row = null,
      len = queue.length;
    for (let i = 0; i < len; i++) {
      // Shift the first node in the queue
      const node = queue.shift();
      // Only accept the first node value
      if (!row) row = node.val;

      // Then push the right node, then the left if the right node does not exist
      if (node.right) queue.push(node.right);
      if (node.left) queue.push(node.left);
    }

    // Push the result in each loop to the final result.
    res.push(row);
  }
  ```

## 4. Related Patterns/Algorithms (Check all that apply)

- [ ] Array
- [ ] String
- [ ] Hash Table / Map
- [ ] Stack
- [x] Queue
- [ ] Linked List
- [x] Tree / Binary Tree
- [ ] Binary Search Tree
- [ ] Heap / Priority Queue
- [x] Graph / BFS / DFS
- [ ] Sliding Window
- [ ] Two Pointers
- [ ] Divide and Conquer
- [ ] Dynamic Programming
- [ ] Greedy
- [ ] Backtracking
- [ ] Bit Manipulation
- [ ] Trie
- [ ] Union Find / Disjoint Set
- [ ] Topological Sort
- [ ] Math
- [ ] Recursion
- [ ] Other:

## 5. Time & Space Complexity

- **Time Complexity:** `O(n)`
  - `n` the total nodes of the tree
- **Space Complexity:** `O(n)`
  - `n` the total nodes of the tree

## 6. Related Problems
