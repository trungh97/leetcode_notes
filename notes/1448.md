# LeetCode Problem Note

## 1. LeetCode Information

- **Title:** [Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree)
- **Difficulty:**
  - [ ] ðŸŸ¢ Easy
  - [x] ðŸŸ¡ Medium
  - [ ] ðŸ”´ Hard
- **Tags:** #btree #bfs #dfs

## 2. Code Idea

- There are 2 ways to resolve this problem:
  - Using DFS recursion/stack.
  - Using queue to perform Breadth-First Search.
- The main idea is to memorize the **max** value in the path to the current node, update the **max** when there is a greater node value appeared.
- Using a variable to **count** each time there is a node value greater than **max**. 

## 3. Key Steps (Pseudo Code at High Level)

- Step 1:
  ```js
  let count = 0
  ```
- Step 2:

  ```js
  // maxSoFar store the current max value in the path.
  function dfs(node, maxSoFar) {
    if (!node) return

    if (maxSoFar <= node.val) {
      maxSoFar = node.val
      count++
    }

    dfs(node.left, maxSoFar)
    dfs(node.right, maxSoFar)
  }
  ```
- Step 3:

  ```js
  // Apply the dfs function to the root.
  dfs(root, root.val)

  // Return the final result.
  return count
  ```

## 4. Related Patterns/Algorithms (Check all that apply)

- [ ] Array
- [ ] String
- [ ] Hash Table / Map
- [x] Stack
- [x] Queue
- [ ] Linked List
- [x] Tree / Binary Tree
- [ ] Binary Search Tree
- [ ] Heap / Priority Queue
- [x] Graph / BFS / DFS
- [ ] Sliding Window
- [ ] Two Pointers
- [ ] Divide and Conquer
- [ ] Dynamic Programming
- [ ] Greedy
- [ ] Backtracking
- [ ] Bit Manipulation
- [ ] Trie
- [ ] Union Find / Disjoint Set
- [ ] Topological Sort
- [ ] Math
- [ ] Recursion
- [ ] Other:

## 5. Time & Space Complexity

- **Time Complexity:** `O(n)`
  - `n` the total nodes of the tree
- **Space Complexity:** `O(h)`
  - `h` the height of the tree

## 6. Related Problems
